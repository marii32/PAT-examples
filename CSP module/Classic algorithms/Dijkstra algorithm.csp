/*
Dijkstra Mutual Exclusion Algorithm

Shared variables:
turn:{1..N}
for every 0 <= i <= (N -1) flag[i]: {0, 1, 2}

turn: initially arbitrary
flag(i): initially 0

Process i:
L: flag(i) := 1
while turn != i do
	if flag(turn) = 0 then turn:= i
flag(i) := 2
for j != i do
	if flag(j) = 2 then goto L
enter critical section
...
exit critical section
flag(i) := 0

*/


#define N 2;

var flag[N];
var enter_cs[N];
var turn;

Process(i) = set_flag.i {flag[i] = 1;} -> (Check1(i) ; (set_flag.i {flag[i] = 2;} -> Check2(i, 0)));

Check1(i) = if(turn != i)				
			{
				if(flag[turn] == 0)
				{
					get_turn{turn = i;} -> Skip
				}
				else
				{
					Check1(i)
				}
			};

Check2(i, j) = 
	if(j==N)
	{
		CS(i)
	}
	else if(j == i)
	{
		Check2(i, j+1)
	}
	else if(flag[j] == 2)
	{
		Process(i)
	}
	else 
	{
		Check2(i, j + 1)
	};
	
CS(i) = cs.i{enter_cs[i] = 1;} -> exit.i {flag[i] = 0; enter_cs[i]= 0;} -> Process(i);


Dijkstra() = [] x:{0..N-1} @ (tau{turn = x} -> (|||y :{0..N-1}@Process(y))); 

//mutual exclution
#define p ((enter_cs[0] + enter_cs[1]) >= 2); 

#assert Dijkstra() deadlockfree;
#assert Dijkstra() reaches p;




