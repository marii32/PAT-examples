//Two Phase Commit Protocol (TPCP)

#define N 2; //number of pages
enum {Yes, No, Commit, Abort}; //constants
//channel result 0;
//channel inform 0;
channel vote 0;
var hasNo = false;
 
//The following models the coordinator 
Coord(decC) = (|||{N}@ request -> Skip); 
			  (|||{N}@ vote?vo -> atomic{tau{if (vo == No) {hasNo = true;}} -> Skip}); 
			  decide -> 
			  (([hasNo == false] (|||{N}@inform.Commit -> Skip); CoordPhaseTwo(Commit)) [] ([hasNo == true] (|||{N}@inform.Abort -> Skip); CoordPhaseTwo(Abort)));
CoordPhaseTwo(decC) = |||{N}@acknowledge -> Skip;

//The following models a page
Page(decP, stable) = request -> execute -> (vote!Yes -> PhaseTwo(decP) [] vote!No -> PhaseTwo(decP));
PhaseTwo(decP) = inform.Commit -> complete -> result.decP -> acknowledge -> Skip
						 [] inform.Abort -> undo -> result.decP -> acknowledge -> Skip;

#alphabet Coord {request, inform.Commit, inform.Abort, acknowledge};
#alphabet Page {request, inform.Commit, inform.Abort, acknowledge};
						
System = Coord(Abort) || (|||{N}@Page(Abort, true));
Implementation = System \{request, execute, acknowledge, inform.Abort, inform.Commit, decide, result.Abort, result.Commit};

#assert System deadlockfree;
#define has hasNo == 1;
#assert System |= [](has -> <> undo);
#assert System |= [](request -> <> undo);

Specification = PC(N);
PC(i) = [i == 0](|||{N}@complete -> Skip)
		[]
		[i > 0]	(vote.Yes -> PC(i-1) [] vote.No -> PU(i-1));
PU(i) = [i == 0](|||{N}@undo -> Skip)
		[]
		[i > 0](vote.Yes -> PU(i-1) [] vote.No -> PU(i-1));
#assert Specification deadlockfree;

#assert Implementation refines Specification;
