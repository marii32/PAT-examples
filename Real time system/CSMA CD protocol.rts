/*
 * In a broadcast network with a multi-access bus, the problem of assigning the bus to only one of many competing stations arises.
 * The CSMA/CD protocol (Carrier Sense, Multiple-Access with Collision Detection) describes one solution.
 * Roughly, whenever a station has data to send, it first listens to the bus.
 * If the bus is idle (i.e., no other station is transmitting), the station begins to send a message.
 * If it detects a busy bus in this process, it waits a random amount of time and then repeats the operation.
 * When a collision occurs, because several stations transmit simultaneously, then all of them detect it,
 * abort their transmissions immediately and wait a random time to start all over again.

 * We suppose that the bus is a 10Mbps Ethernet with a worst case propagation delay of 26 usec.
 * Messages have a fixed length of 1024 bytes and so the time to send a complete message including the propagation delay is 808 usec.
 * For simplicity we make the following assumptions the bus is error free
 * only the transmission of messages is modeled and no buffering of incoming messages is allowed.
*/


////////////////////////////////////////The Model//////////////////////////////////////////////////

#define N 4; //Number of Stations

channel begin 0; //Sender starts sending the messages
channel busy 0; //the bus is sensed busy by Sender
channel end 0; //Sender completes the transmission
channel cd 0; //A collision is detected by Sender
channel newMess 0; //A message is fetched by Sender

////////////////////////////////////////Processes//////////////////////////////////////////////////////
//Model Sender
//WaitFor(i): Sender(i) is waiting for a message from the upper level
WaitFor(i) = (cd?i -> WaitFor(i)) [] (newMess!i -> ((begin!i -> Trans(i)) [] (cd?i -> Retry(i)) [] (busy?i -> Retry(i))));
//Trans(i): Sender(i) is sending a message
Trans(i) = (cd?i -> Retry(i)) timeout[52] (Wait[756]; end!i -> WaitFor(i)within[0]);
//Retry(i): Sender is waiting to retry after detecting a collision or a busy bus
Retry(i) = (newMess!i -> ((begin!i -> Trans(i) within[52]) [] (busy?i -> Retry(i) within [52]) [] (cd?i -> Retry(i) within[52])))
            [] (cd?i -> Retry(i));

//Model Bus
//Idle: No station is transmitting
Idle = newMess?i -> begin?i -> Active;
//Active: Some station has started a transmission
Active = (end?i -> Idle) [] ((newMess?i -> begin?i ->> Collision) timeout[26] (newMess?i -> busy!i ->> Active1 within[0]));
//Active1: One station is transmitting messages
Active1 = (end?i -> Idle) [] (newMess?i -> busy!i ->Active1);
//Collison: the burst noise of a collision is being propagated
Collision = notifyCD ->> atomic{BroadcastCD(0)} within[26];Idle;
					
//Broadcast collision signal to every sender					
BroadcastCD(x) = if (x < N) {
						cd!x -> BroadcastCD(x+1)
						[]
						(newMess?[i==x]i -> cd!x ->BroadcastCD(x+1))
					}
					else {
						Skip
					};

CSMACD=(|||x :{0..N-1}@WaitFor(x))|||Idle;

///////////////////////////////////The Properties//////////////////////////////////////////////////
#assert CSMACD deadlockfree;

//Two stations can not transmit simultaneously after one has listened to the bus for more than 52 time slots
SpecProcess = (newMess.0 -> begin.0 -> Constrained1)  // if begin.0 occurs, then constrained1 happens
	   [] (newMess.1 -> begin.1 -> (
	   		newMess.0 -> begin.0 -> Constrained2 // if begin.1 occurs and then followed by begin.0, then constrained2 happens
	   		[]
	   		Relaxed //otherwise, no constrain applies.
	   )) 
	   [] Relaxed; 

//constrain1 states that given that begin.0 has occured, if begin.1 occurs, cd.0 or cd.1 must occur within 52 time slots 
Constrained1 = ((newMess.1 -> begin.1 -> ((cd.0 -> Skip [] cd.1 -> Skip) deadline[52])); SpecProcess) [] Relaxed;
//constrain1 states that given that begin.1 and begin.0 have occured, cd.0 or cd.1 must occur within 52 time slots 
Constrained2 = (cd.0 -> Skip [] cd.1 -> Skip) deadline[52]; Relaxed;
//the following process states that other than the above, the rest of the system is not constrained.

Relaxed = ([] x:{2..N-1} @ (newMess.x -> begin.x -> SpecProcess)) []
			([] x:{0..N-1} @ ((newMess.x -> (busy.x -> SpecProcess [] cd.x -> SpecProcess))[] (cd.x -> SpecProcess)
	   		[] (end.x -> SpecProcess) )
	   		); 

CSMACD_Ref = CSMACD\{notifyCD};
               
#assert CSMACD |= []<> ((begin.0 && <> begin.1) -> <> (cd.0 || cd.1));
