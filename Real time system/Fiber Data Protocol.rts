/*
 * Fiber Distributed Data Interface(FDDI) is a high-performance fiber-optic
 * token ring Local Area Network. An FDDI network is composed by N identical
 * stations and a ring, where the stations can communicate by synchronous
 * messages with high priority or synchronous messages with low priority.
 */

////////////////////////////////////////////The Model//////////////////////////////////////////////////

#define N 3; //Number of stations
#define td 0; //No delay in the token passing of the ring
#define TTRT 170; //Target token Rotation Timer
#define SA 20; //Time units for synchronous transmission

channel tt 0; // Synchronization token transaction from token to station
channel rt 0; // Synchronize release transaction from station to token

////////////////////////////////////////Processes//////////////////////////////////////////////////////
//Model Ring 
//Send token to station i
Token_to(i) = (tt!i -> Token(i) within [td]);
//When receives release token message of station i, pass the token to next station
Token(i) = rt?i -> Token_to((i+1) % N);

//Model Station
Station_z_idle(i) = tt?i ->  startY.i ->> Station_z_sync(i);

Station_z_sync(i) = Wait[SA];(withinZ.i ->> Station_z_async(i) [] withoutZ.i ->> rt!i ->> Station_y_idle(i));
Station_z_async(i) = rt!i -> Station_y_idle(i);

Station_y_idle(i) =  tt?i -> startZ.i ->> Station_y_sync(i);
Station_y_sync(i) = Wait[SA]; (withinY.i ->> Station_y_async(i) [] withoutY.i ->> rt!i ->> Station_z_idle(i));
Station_y_async(i) = rt!i -> Station_z_idle(i);

Z(i) = (startZ.i->Skip [] initiateZ->Skip); ((withinZ.i -> Z(i)) timeout[TTRT] withoutZ.i -> Z(i));

Y(i) = startY.i-> ((withinY.i -> Y(i)) timeout[TTRT] withoutY.i -> Y(i));

System = (||x :{0..N-1}@((initiateZ -> Station_z_idle(x))|| Z(x) || Y(x)))||| Token_to(0);

///////////////////////////////////The Properties//////////////////////////////////////////////////
#assert System deadlockfree;

// Safety property: the token is not at two places at the same time
#assert System |= []!((withinZ.0 || withoutZ.0 || withinY.0 || withoutY.0) && (withinZ.1 || withoutZ.1 || withinY.1 || withoutY.1));
